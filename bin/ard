#!/usr/bin/env node

const {
  start, stop, setInstance, getInstance
} = require('../')
const { getIdentifier } = require('ara-util')
const { info, warn, error } = require('ara-console')
const { basename } = require('path')
const inquirer = require('inquirer')
const program = require('yargs')
const clip = require('cli-progress')
const DCDN = require('../src/dcdn')
const rc = require('ara-runtime-configuration')()

const $0 = basename(process.argv[1])

process.title = $0
process.on('unhandledRejection', onClose)
process.on('uncaughtExeption', onClose)

// program usage
program
  .usage('usage: $0 [-hDV] <command> [options]')
  .wrap(null)

// booleans
program
  .group([ 'help', 'version', 'debug' ], 'General Options:')
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: 'Enable debug output'
  })
  .option('help', {
    alias: 'h',
    describe: 'Show this help message'
  })
  .option('version', {
    alias: 'V',
    describe: 'Show program version'
  })

// parameters
program
  .group([ 'identity', 'did' ], 'Command Options:')

program.option('identity', {
  alias: 'i',
  type: 'string',
  required: true,
  default: rc.network.identity.whoami,
  describe:
  `A valid, local, and resolvable Ara identity DID
  URI of the owner of the AFS. You will be
  prompted for the associated passphrase`,
})

program.option('did', {
  alias: 'd',
  type: 'string',
  describe:
  `A valid and resolvable Ara identity DID URI
  of an AFS.`,
})

program.option('reward', {
  alias: 'r',
  type: 'number',
  describe:
  `The maximum reward you want to receive/give for 
  uploading/downloading an AFS. The default is 10%
  of the price of an AFS.`
})

program.option('peers', {
  alias: 'p',
  type: 'number',
  describe:
  `The maximum number of peers you want to connect 
  with when uploading/downloading an AFS.`,
  default: 10
})

program.command(
  'download',
  'Download AFS from network',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] download [options]')
  , ondownload
)

program.command(
  'seed',
  'Host AFS for network',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] seed [options]')
  , onseed
)

program.command(
  'metadata',
  'Sync metadata with the network',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] metadata [options]')
  , onmetadata
)

program.command(
  'start',
  'Start the DCDN Node with the most recent configuration',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] start [options]')
  , onstart
)

if (0 === program.argv._.length) {
  program.showHelp()
  process.exit(1)
}

if (program.argv.debug) {
  require('debug').enable('ard*,arp*')
}

async function onstart(argv) {
  info('starting DCDN node')
  try {
    let dcdn = await getInstance()
    if (!dcdn) {
      const password = await getPassword()
      dcdn = new DCDN({
        password,
        userID: argv.identity
      })
      await setInstance(dcdn)
      displayEvents(dcdn)
    }
    await start()
  } catch (e) {
    onClose(`Error occurred with starting DCDN Node: ${e}`)
  }
}

async function ondownload(argv) {
  const did = getIdentifier(argv.did || await getDid())

  info(`starting DCDN to download ${did}`)

  // TODO: add confirmation about expected price for download, i.e. 10% of price

  try {
    let dcdn = await getInstance()
    if (!dcdn) {
      const password = await getPassword()
      dcdn = new DCDN({
        password,
        userID: argv.identity
      })
      await setInstance(dcdn)
      displayEvents(dcdn)
    }

    await start({
      did,
      download: true,
      upload: false,
      reward: argv.reward,
      peers: argv.peers
    })
  } catch (e) {
    onClose(`Error occurred while downloading ${did}: ${e}`)
  }
}

async function onseed(argv) {
  const did = getIdentifier(argv.did || await getDid())
  info(`starting DCDN to seed ${did}`)

  // TODO: add confirmation about expected reward for upload, i.e. 10% of price

  try {
    let dcdn = await getInstance()
    if (!dcdn) {
      const password = await getPassword()
      dcdn = new DCDN({
        password,
        userID: argv.identity
      })
      await setInstance(dcdn)
      displayEvents(dcdn)
    }

    await start({
      did,
      download: false,
      upload: true,
      reward: argv.reward,
      peers: argv.peers
    })
  } catch (e) {
    onClose(`Error occurred while seeding DID ${did}: ${e}`)
  }
}

async function onmetadata(argv) {
  const did = getIdentifier(argv.did || await getDid())
  info(`starting DCDN to sync metadata for ${did}`)

  try {
    let dcdn = await getInstance()
    if (!dcdn) {
      const password = await getPassword()
      dcdn = new DCDN({
        password,
        userID: argv.identity
      })
      await setInstance(dcdn)
      displayEvents(dcdn)
    }

    await start({
      did,
      download: true,
      upload: false,
      peers: argv.peers,
      metaOnly: true
    })
  } catch (e) {
    onClose(`Error occurred while syncing metadata ${did}: ${e}`)
  }
}

async function getPassword() {
  const { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please enter the passphrase associated with the node identity.\n' +
    'Passphrase:'
  } ])
  return password
}

async function getDid() {
  const { did } = await inquirer.prompt([ {
    type: 'string',
    name: 'did',
    message:
    'Please enter the DID associated with the AFS.\n' +
    'DID:'
  } ])
  return did
}

async function onClose(err) {
  if (err) {
    error('fatal:', err)
    process.exit(1)
  } else {
    try {
      await stop()
      process.exit(0)
    } catch (e) {
      error('fatal:', e)
      process.exit(1)
    }
  }
}

function displayEvents(dcdn) {
  // Creates a progress visualizer bar in cli
  const visualizers = new Map()

  dcdn.on('start', (did, total) => {
    if (visualizers.has(did)) return
    info(`Download started for ${did}`)
    const pBar = new clip.Bar({}, clip.Presets.shades_classic)
    pBar.start(total, 0)
    visualizers.set(did, pBar)
  })

  dcdn.on('progress', (did, value) => {
    if (!visualizers.has(did)) return
    const pBar = visualizers.get(did)
    pBar.update(value)
  })

  dcdn.on('complete', (did) => {
    if (!visualizers.has(did)) return
    const pBar = visualizers.get(did)
    pBar.stop()
    info(`Download complete for ${did}`)
    visualizers.delete(did)
  })

  dcdn.on('info', (message) => {
    info(message)
  })

  dcdn.on('warn', (message) => {
    warn(message)
  })

  dcdn.on('requestcomplete', (key) => {
    info(`Request complete for ${key}`)
  })
}
